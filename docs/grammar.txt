Grammar:

Rule 0     S' -> prog
Rule 1     prog -> decl_list
Rule 2     decl_list -> empty
Rule 3     decl_list -> decl decl_list
Rule 4     decl -> decl_init
Rule 5     decl -> ID : function_type ;
Rule 6     decl -> ID : array_type ;
Rule 7     decl -> ID : type_name = expr ;
Rule 8     decl -> ID : type_name ;
Rule 9     decl_init -> ID : function_type = { opt_stmt_list }
Rule 10    decl_init -> ID : array_type = { opt_expr_list } ;
Rule 11    type_name -> VOID
Rule 12    type_name -> STRING
Rule 13    type_name -> CHAR
Rule 14    type_name -> BOOLEAN
Rule 15    type_name -> FLOAT
Rule 16    type_name -> INTEGER
Rule 17    array_type -> ARRAY [ expr ] type_name
Rule 18    array_type -> ARRAY [ ] type_name
Rule 19    function_type -> FUNCTION type_name ( opt_param_list )
Rule 20    opt_param_list -> param_list
Rule 21    opt_param_list -> empty
Rule 22    param_list -> param
Rule 23    param_list -> param_list , param
Rule 24    param -> ID : array_type
Rule 25    param -> ID : type_name
Rule 26    opt_stmt_list -> empty
Rule 27    opt_stmt_list -> stmt_list
Rule 28    stmt_list -> stmt
Rule 29    stmt_list -> stmt stmt_list
Rule 30    stmt -> expr ;
Rule 31    stmt -> decl
Rule 32    stmt -> block_stmt
Rule 33    stmt -> return_stmt
Rule 34    stmt -> print_stmt
Rule 35    stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
Rule 36    stmt -> IF ( expr ) stmt ELSE stmt
Rule 37    stmt -> IF ( expr ) stmt
Rule 38    stmt -> DO stmt WHILE ( expr ) ;
Rule 39    stmt -> WHILE ( expr ) stmt
Rule 40    print_stmt -> PRINT opt_expr_list ;
Rule 41    return_stmt -> RETURN opt_expr ;
Rule 42    block_stmt -> { stmt_list }
Rule 43    opt_expr_list -> expr_list
Rule 44    opt_expr_list -> empty
Rule 45    expr_list -> expr
Rule 46    expr_list -> expr , expr_list
Rule 47    opt_expr -> expr
Rule 48    opt_expr -> empty
Rule 49    expr -> FALSE
Rule 50    expr -> TRUE
Rule 51    expr -> STRING_CONST
Rule 52    expr -> CHAR_CONST
Rule 53    expr -> FLOAT_CONST
Rule 54    expr -> INTEGER_CONST
Rule 55    expr -> ID
Rule 56    expr -> ID [ expr ]
Rule 57    expr -> ID ( opt_expr_list )
Rule 58    expr -> ( expr )
Rule 59    expr -> DEC expr  [precedence=right, level=8]
Rule 60    expr -> INC expr  [precedence=right, level=8]
Rule 61    expr -> NOT expr  [precedence=right, level=8]
Rule 62    expr -> - expr  [precedence=right, level=8]
Rule 63    expr -> expr ^ expr  [precedence=right, level=7]
Rule 64    expr -> expr % expr  [precedence=left, level=6]
Rule 65    expr -> expr / expr  [precedence=left, level=6]
Rule 66    expr -> expr * expr  [precedence=left, level=6]
Rule 67    expr -> expr - expr  [precedence=left, level=5]
Rule 68    expr -> expr + expr  [precedence=left, level=5]
Rule 69    expr -> expr DEC  [precedence=right, level=8]
Rule 70    expr -> expr INC  [precedence=right, level=8]
Rule 71    expr -> expr MAYOR_IGUAL expr  [precedence=nonassoc, level=4]
Rule 72    expr -> expr MAYOR_QUE expr  [precedence=nonassoc, level=4]
Rule 73    expr -> expr MENOR_IGUAL expr  [precedence=nonassoc, level=4]
Rule 74    expr -> expr MENOR_QUE expr  [precedence=nonassoc, level=4]
Rule 75    expr -> expr NO_IGUAL expr  [precedence=nonassoc, level=4]
Rule 76    expr -> expr IGUAL expr  [precedence=nonassoc, level=4]
Rule 77    expr -> expr AND expr  [precedence=left, level=3]
Rule 78    expr -> expr OR expr  [precedence=left, level=2]
Rule 79    expr -> lval = expr  [precedence=right, level=1]
Rule 80    lval -> ID [ expr ]
Rule 81    lval -> ID
Rule 82    empty -> <empty>

Unused terminals:

    AUTO
    CONTINUE
    BREAK

Terminals, with rules where they appear:

%                    : 64
(                    : 19 35 36 37 38 39 57 58
)                    : 19 35 36 37 38 39 57 58
*                    : 66
+                    : 68
,                    : 23 46
-                    : 62 67
/                    : 65
:                    : 5 6 7 8 9 10 24 25
;                    : 5 6 7 8 10 30 35 35 38 40 41
=                    : 7 9 10 79
AND                  : 77
ARRAY                : 17 18
AUTO                 : 
BOOLEAN              : 14
BREAK                : 
CHAR                 : 13
CHAR_CONST           : 52
CONTINUE             : 
DEC                  : 59 69
DO                   : 38
ELSE                 : 36
FALSE                : 49
FLOAT                : 15
FLOAT_CONST          : 53
FOR                  : 35
FUNCTION             : 19
ID                   : 5 6 7 8 9 10 24 25 55 56 57 80 81
IF                   : 36 37
IGUAL                : 76
INC                  : 60 70
INTEGER              : 16
INTEGER_CONST        : 54
MAYOR_IGUAL          : 71
MAYOR_QUE            : 72
MENOR_IGUAL          : 73
MENOR_QUE            : 74
NOT                  : 61
NO_IGUAL             : 75
OR                   : 78
PRINT                : 40
RETURN               : 41
STRING               : 12
STRING_CONST         : 51
TRUE                 : 50
VOID                 : 11
WHILE                : 38 39
[                    : 17 18 56 80
]                    : 17 18 56 80
^                    : 63
error                : 
{                    : 9 10 42
}                    : 9 10 42

Nonterminals, with rules where they appear:

array_type           : 6 10 24
block_stmt           : 32
decl                 : 3 31
decl_init            : 4
decl_list            : 1 3
empty                : 2 21 26 44 48
expr                 : 7 17 30 36 37 38 39 45 46 47 56 58 59 60 61 62 63 63 64 64 65 65 66 66 67 67 68 68 69 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 80
expr_list            : 43 46
function_type        : 5 9
lval                 : 79
opt_expr             : 35 35 35 41
opt_expr_list        : 10 40 57
opt_param_list       : 19
opt_stmt_list        : 9
param                : 22 23
param_list           : 20 23
print_stmt           : 34
prog                 : 0
return_stmt          : 33
stmt                 : 28 29 35 36 36 37 38 39
stmt_list            : 27 29 42
type_name            : 7 8 17 18 19 25


state 0

    (0) S' -> . prog
    (1) prog -> . decl_list
    (2) decl_list -> . empty
    (3) decl_list -> . decl decl_list
    (82) empty -> .
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    $end            reduce using rule 82 (empty -> .)
    ID              shift and go to state 6

    prog                           shift and go to state 1
    decl_list                      shift and go to state 2
    empty                          shift and go to state 3
    decl                           shift and go to state 4
    decl_init                      shift and go to state 5

state 1

    (0) S' -> prog .


state 2

    (1) prog -> decl_list .
    $end            reduce using rule 1 (prog -> decl_list .)


state 3

    (2) decl_list -> empty .
    $end            reduce using rule 2 (decl_list -> empty .)


state 4

    (3) decl_list -> decl . decl_list
    (2) decl_list -> . empty
    (3) decl_list -> . decl decl_list
    (82) empty -> .
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    $end            reduce using rule 82 (empty -> .)
    ID              shift and go to state 6

    decl                           shift and go to state 4
    decl_list                      shift and go to state 7
    empty                          shift and go to state 3
    decl_init                      shift and go to state 5

state 5

    (4) decl -> decl_init .
    ID              reduce using rule 4 (decl -> decl_init .)
    $end            reduce using rule 4 (decl -> decl_init .)
    FOR             reduce using rule 4 (decl -> decl_init .)
    IF              reduce using rule 4 (decl -> decl_init .)
    DO              reduce using rule 4 (decl -> decl_init .)
    WHILE           reduce using rule 4 (decl -> decl_init .)
    FALSE           reduce using rule 4 (decl -> decl_init .)
    TRUE            reduce using rule 4 (decl -> decl_init .)
    STRING_CONST    reduce using rule 4 (decl -> decl_init .)
    CHAR_CONST      reduce using rule 4 (decl -> decl_init .)
    FLOAT_CONST     reduce using rule 4 (decl -> decl_init .)
    INTEGER_CONST   reduce using rule 4 (decl -> decl_init .)
    (               reduce using rule 4 (decl -> decl_init .)
    DEC             reduce using rule 4 (decl -> decl_init .)
    INC             reduce using rule 4 (decl -> decl_init .)
    NOT             reduce using rule 4 (decl -> decl_init .)
    -               reduce using rule 4 (decl -> decl_init .)
    {               reduce using rule 4 (decl -> decl_init .)
    RETURN          reduce using rule 4 (decl -> decl_init .)
    PRINT           reduce using rule 4 (decl -> decl_init .)
    }               reduce using rule 4 (decl -> decl_init .)
    ELSE            reduce using rule 4 (decl -> decl_init .)


state 6

    (5) decl -> ID . : function_type ;
    (6) decl -> ID . : array_type ;
    (7) decl -> ID . : type_name = expr ;
    (8) decl -> ID . : type_name ;
    (9) decl_init -> ID . : function_type = { opt_stmt_list }
    (10) decl_init -> ID . : array_type = { opt_expr_list } ;
    :               shift and go to state 8


state 7

    (3) decl_list -> decl decl_list .
    $end            reduce using rule 3 (decl_list -> decl decl_list .)


state 8

    (5) decl -> ID : . function_type ;
    (6) decl -> ID : . array_type ;
    (7) decl -> ID : . type_name = expr ;
    (8) decl -> ID : . type_name ;
    (9) decl_init -> ID : . function_type = { opt_stmt_list }
    (10) decl_init -> ID : . array_type = { opt_expr_list } ;
    (19) function_type -> . FUNCTION type_name ( opt_param_list )
    (17) array_type -> . ARRAY [ expr ] type_name
    (18) array_type -> . ARRAY [ ] type_name
    (11) type_name -> . VOID
    (12) type_name -> . STRING
    (13) type_name -> . CHAR
    (14) type_name -> . BOOLEAN
    (15) type_name -> . FLOAT
    (16) type_name -> . INTEGER
    FUNCTION        shift and go to state 12
    ARRAY           shift and go to state 13
    VOID            shift and go to state 14
    STRING          shift and go to state 15
    CHAR            shift and go to state 16
    BOOLEAN         shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19

    function_type                  shift and go to state 9
    array_type                     shift and go to state 10
    type_name                      shift and go to state 11

state 9

    (5) decl -> ID : function_type . ;
    (9) decl_init -> ID : function_type . = { opt_stmt_list }
    ;               shift and go to state 20
    =               shift and go to state 21


state 10

    (6) decl -> ID : array_type . ;
    (10) decl_init -> ID : array_type . = { opt_expr_list } ;
    ;               shift and go to state 22
    =               shift and go to state 23


state 11

    (7) decl -> ID : type_name . = expr ;
    (8) decl -> ID : type_name . ;
    =               shift and go to state 24
    ;               shift and go to state 25


state 12

    (19) function_type -> FUNCTION . type_name ( opt_param_list )
    (11) type_name -> . VOID
    (12) type_name -> . STRING
    (13) type_name -> . CHAR
    (14) type_name -> . BOOLEAN
    (15) type_name -> . FLOAT
    (16) type_name -> . INTEGER
    VOID            shift and go to state 14
    STRING          shift and go to state 15
    CHAR            shift and go to state 16
    BOOLEAN         shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19

    type_name                      shift and go to state 26

state 13

    (17) array_type -> ARRAY . [ expr ] type_name
    (18) array_type -> ARRAY . [ ] type_name
    [               shift and go to state 27


state 14

    (11) type_name -> VOID .
    =               reduce using rule 11 (type_name -> VOID .)
    ;               reduce using rule 11 (type_name -> VOID .)
    (               reduce using rule 11 (type_name -> VOID .)
    ,               reduce using rule 11 (type_name -> VOID .)
    )               reduce using rule 11 (type_name -> VOID .)


state 15

    (12) type_name -> STRING .
    =               reduce using rule 12 (type_name -> STRING .)
    ;               reduce using rule 12 (type_name -> STRING .)
    (               reduce using rule 12 (type_name -> STRING .)
    ,               reduce using rule 12 (type_name -> STRING .)
    )               reduce using rule 12 (type_name -> STRING .)


state 16

    (13) type_name -> CHAR .
    =               reduce using rule 13 (type_name -> CHAR .)
    ;               reduce using rule 13 (type_name -> CHAR .)
    (               reduce using rule 13 (type_name -> CHAR .)
    ,               reduce using rule 13 (type_name -> CHAR .)
    )               reduce using rule 13 (type_name -> CHAR .)


state 17

    (14) type_name -> BOOLEAN .
    =               reduce using rule 14 (type_name -> BOOLEAN .)
    ;               reduce using rule 14 (type_name -> BOOLEAN .)
    (               reduce using rule 14 (type_name -> BOOLEAN .)
    ,               reduce using rule 14 (type_name -> BOOLEAN .)
    )               reduce using rule 14 (type_name -> BOOLEAN .)


state 18

    (15) type_name -> FLOAT .
    =               reduce using rule 15 (type_name -> FLOAT .)
    ;               reduce using rule 15 (type_name -> FLOAT .)
    (               reduce using rule 15 (type_name -> FLOAT .)
    ,               reduce using rule 15 (type_name -> FLOAT .)
    )               reduce using rule 15 (type_name -> FLOAT .)


state 19

    (16) type_name -> INTEGER .
    =               reduce using rule 16 (type_name -> INTEGER .)
    ;               reduce using rule 16 (type_name -> INTEGER .)
    (               reduce using rule 16 (type_name -> INTEGER .)
    ,               reduce using rule 16 (type_name -> INTEGER .)
    )               reduce using rule 16 (type_name -> INTEGER .)


state 20

    (5) decl -> ID : function_type ; .
    ID              reduce using rule 5 (decl -> ID : function_type ; .)
    $end            reduce using rule 5 (decl -> ID : function_type ; .)
    FOR             reduce using rule 5 (decl -> ID : function_type ; .)
    IF              reduce using rule 5 (decl -> ID : function_type ; .)
    DO              reduce using rule 5 (decl -> ID : function_type ; .)
    WHILE           reduce using rule 5 (decl -> ID : function_type ; .)
    FALSE           reduce using rule 5 (decl -> ID : function_type ; .)
    TRUE            reduce using rule 5 (decl -> ID : function_type ; .)
    STRING_CONST    reduce using rule 5 (decl -> ID : function_type ; .)
    CHAR_CONST      reduce using rule 5 (decl -> ID : function_type ; .)
    FLOAT_CONST     reduce using rule 5 (decl -> ID : function_type ; .)
    INTEGER_CONST   reduce using rule 5 (decl -> ID : function_type ; .)
    (               reduce using rule 5 (decl -> ID : function_type ; .)
    DEC             reduce using rule 5 (decl -> ID : function_type ; .)
    INC             reduce using rule 5 (decl -> ID : function_type ; .)
    NOT             reduce using rule 5 (decl -> ID : function_type ; .)
    -               reduce using rule 5 (decl -> ID : function_type ; .)
    {               reduce using rule 5 (decl -> ID : function_type ; .)
    RETURN          reduce using rule 5 (decl -> ID : function_type ; .)
    PRINT           reduce using rule 5 (decl -> ID : function_type ; .)
    }               reduce using rule 5 (decl -> ID : function_type ; .)
    ELSE            reduce using rule 5 (decl -> ID : function_type ; .)


state 21

    (9) decl_init -> ID : function_type = . { opt_stmt_list }
    {               shift and go to state 28


state 22

    (6) decl -> ID : array_type ; .
    ID              reduce using rule 6 (decl -> ID : array_type ; .)
    $end            reduce using rule 6 (decl -> ID : array_type ; .)
    FOR             reduce using rule 6 (decl -> ID : array_type ; .)
    IF              reduce using rule 6 (decl -> ID : array_type ; .)
    DO              reduce using rule 6 (decl -> ID : array_type ; .)
    WHILE           reduce using rule 6 (decl -> ID : array_type ; .)
    FALSE           reduce using rule 6 (decl -> ID : array_type ; .)
    TRUE            reduce using rule 6 (decl -> ID : array_type ; .)
    STRING_CONST    reduce using rule 6 (decl -> ID : array_type ; .)
    CHAR_CONST      reduce using rule 6 (decl -> ID : array_type ; .)
    FLOAT_CONST     reduce using rule 6 (decl -> ID : array_type ; .)
    INTEGER_CONST   reduce using rule 6 (decl -> ID : array_type ; .)
    (               reduce using rule 6 (decl -> ID : array_type ; .)
    DEC             reduce using rule 6 (decl -> ID : array_type ; .)
    INC             reduce using rule 6 (decl -> ID : array_type ; .)
    NOT             reduce using rule 6 (decl -> ID : array_type ; .)
    -               reduce using rule 6 (decl -> ID : array_type ; .)
    {               reduce using rule 6 (decl -> ID : array_type ; .)
    RETURN          reduce using rule 6 (decl -> ID : array_type ; .)
    PRINT           reduce using rule 6 (decl -> ID : array_type ; .)
    }               reduce using rule 6 (decl -> ID : array_type ; .)
    ELSE            reduce using rule 6 (decl -> ID : array_type ; .)


state 23

    (10) decl_init -> ID : array_type = . { opt_expr_list } ;
    {               shift and go to state 29


state 24

    (7) decl -> ID : type_name = . expr ;
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 31
    lval                           shift and go to state 43

state 25

    (8) decl -> ID : type_name ; .
    ID              reduce using rule 8 (decl -> ID : type_name ; .)
    $end            reduce using rule 8 (decl -> ID : type_name ; .)
    FOR             reduce using rule 8 (decl -> ID : type_name ; .)
    IF              reduce using rule 8 (decl -> ID : type_name ; .)
    DO              reduce using rule 8 (decl -> ID : type_name ; .)
    WHILE           reduce using rule 8 (decl -> ID : type_name ; .)
    FALSE           reduce using rule 8 (decl -> ID : type_name ; .)
    TRUE            reduce using rule 8 (decl -> ID : type_name ; .)
    STRING_CONST    reduce using rule 8 (decl -> ID : type_name ; .)
    CHAR_CONST      reduce using rule 8 (decl -> ID : type_name ; .)
    FLOAT_CONST     reduce using rule 8 (decl -> ID : type_name ; .)
    INTEGER_CONST   reduce using rule 8 (decl -> ID : type_name ; .)
    (               reduce using rule 8 (decl -> ID : type_name ; .)
    DEC             reduce using rule 8 (decl -> ID : type_name ; .)
    INC             reduce using rule 8 (decl -> ID : type_name ; .)
    NOT             reduce using rule 8 (decl -> ID : type_name ; .)
    -               reduce using rule 8 (decl -> ID : type_name ; .)
    {               reduce using rule 8 (decl -> ID : type_name ; .)
    RETURN          reduce using rule 8 (decl -> ID : type_name ; .)
    PRINT           reduce using rule 8 (decl -> ID : type_name ; .)
    }               reduce using rule 8 (decl -> ID : type_name ; .)
    ELSE            reduce using rule 8 (decl -> ID : type_name ; .)


state 26

    (19) function_type -> FUNCTION type_name . ( opt_param_list )
    (               shift and go to state 44


state 27

    (17) array_type -> ARRAY [ . expr ] type_name
    (18) array_type -> ARRAY [ . ] type_name
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    ]               shift and go to state 46
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 45
    lval                           shift and go to state 43

state 28

    (9) decl_init -> ID : function_type = { . opt_stmt_list }
    (26) opt_stmt_list -> . empty
    (27) opt_stmt_list -> . stmt_list
    (82) empty -> .
    (28) stmt_list -> . stmt
    (29) stmt_list -> . stmt stmt_list
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    }               reduce using rule 82 (empty -> .)
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    opt_stmt_list                  shift and go to state 49
    empty                          shift and go to state 50
    stmt_list                      shift and go to state 51
    stmt                           shift and go to state 52
    expr                           shift and go to state 53
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 29

    (10) decl_init -> ID : array_type = { . opt_expr_list } ;
    (43) opt_expr_list -> . expr_list
    (44) opt_expr_list -> . empty
    (45) expr_list -> . expr
    (46) expr_list -> . expr , expr_list
    (82) empty -> .
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    }               reduce using rule 82 (empty -> .)
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    opt_expr_list                  shift and go to state 64
    expr_list                      shift and go to state 65
    empty                          shift and go to state 66
    expr                           shift and go to state 67
    lval                           shift and go to state 43

state 30

    (55) expr -> ID .
    (56) expr -> ID . [ expr ]
    (57) expr -> ID . ( opt_expr_list )
    (80) lval -> ID . [ expr ]
    (81) lval -> ID .
    ;               reduce using rule 55 (expr -> ID .)
    ^               reduce using rule 55 (expr -> ID .)
    %               reduce using rule 55 (expr -> ID .)
    /               reduce using rule 55 (expr -> ID .)
    *               reduce using rule 55 (expr -> ID .)
    -               reduce using rule 55 (expr -> ID .)
    +               reduce using rule 55 (expr -> ID .)
    DEC             reduce using rule 55 (expr -> ID .)
    INC             reduce using rule 55 (expr -> ID .)
    MAYOR_IGUAL     reduce using rule 55 (expr -> ID .)
    MAYOR_QUE       reduce using rule 55 (expr -> ID .)
    MENOR_IGUAL     reduce using rule 55 (expr -> ID .)
    MENOR_QUE       reduce using rule 55 (expr -> ID .)
    NO_IGUAL        reduce using rule 55 (expr -> ID .)
    IGUAL           reduce using rule 55 (expr -> ID .)
    AND             reduce using rule 55 (expr -> ID .)
    OR              reduce using rule 55 (expr -> ID .)
    ]               reduce using rule 55 (expr -> ID .)
    ,               reduce using rule 55 (expr -> ID .)
    }               reduce using rule 55 (expr -> ID .)
    )               reduce using rule 55 (expr -> ID .)
    [               shift and go to state 68
    (               shift and go to state 69
    =               reduce using rule 81 (lval -> ID .)


state 31

    (7) decl -> ID : type_name = expr . ;
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               shift and go to state 70
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 32

    (49) expr -> FALSE .
    ;               reduce using rule 49 (expr -> FALSE .)
    ^               reduce using rule 49 (expr -> FALSE .)
    %               reduce using rule 49 (expr -> FALSE .)
    /               reduce using rule 49 (expr -> FALSE .)
    *               reduce using rule 49 (expr -> FALSE .)
    -               reduce using rule 49 (expr -> FALSE .)
    +               reduce using rule 49 (expr -> FALSE .)
    DEC             reduce using rule 49 (expr -> FALSE .)
    INC             reduce using rule 49 (expr -> FALSE .)
    MAYOR_IGUAL     reduce using rule 49 (expr -> FALSE .)
    MAYOR_QUE       reduce using rule 49 (expr -> FALSE .)
    MENOR_IGUAL     reduce using rule 49 (expr -> FALSE .)
    MENOR_QUE       reduce using rule 49 (expr -> FALSE .)
    NO_IGUAL        reduce using rule 49 (expr -> FALSE .)
    IGUAL           reduce using rule 49 (expr -> FALSE .)
    AND             reduce using rule 49 (expr -> FALSE .)
    OR              reduce using rule 49 (expr -> FALSE .)
    ]               reduce using rule 49 (expr -> FALSE .)
    ,               reduce using rule 49 (expr -> FALSE .)
    }               reduce using rule 49 (expr -> FALSE .)
    )               reduce using rule 49 (expr -> FALSE .)


state 33

    (50) expr -> TRUE .
    ;               reduce using rule 50 (expr -> TRUE .)
    ^               reduce using rule 50 (expr -> TRUE .)
    %               reduce using rule 50 (expr -> TRUE .)
    /               reduce using rule 50 (expr -> TRUE .)
    *               reduce using rule 50 (expr -> TRUE .)
    -               reduce using rule 50 (expr -> TRUE .)
    +               reduce using rule 50 (expr -> TRUE .)
    DEC             reduce using rule 50 (expr -> TRUE .)
    INC             reduce using rule 50 (expr -> TRUE .)
    MAYOR_IGUAL     reduce using rule 50 (expr -> TRUE .)
    MAYOR_QUE       reduce using rule 50 (expr -> TRUE .)
    MENOR_IGUAL     reduce using rule 50 (expr -> TRUE .)
    MENOR_QUE       reduce using rule 50 (expr -> TRUE .)
    NO_IGUAL        reduce using rule 50 (expr -> TRUE .)
    IGUAL           reduce using rule 50 (expr -> TRUE .)
    AND             reduce using rule 50 (expr -> TRUE .)
    OR              reduce using rule 50 (expr -> TRUE .)
    ]               reduce using rule 50 (expr -> TRUE .)
    ,               reduce using rule 50 (expr -> TRUE .)
    }               reduce using rule 50 (expr -> TRUE .)
    )               reduce using rule 50 (expr -> TRUE .)


state 34

    (51) expr -> STRING_CONST .
    ;               reduce using rule 51 (expr -> STRING_CONST .)
    ^               reduce using rule 51 (expr -> STRING_CONST .)
    %               reduce using rule 51 (expr -> STRING_CONST .)
    /               reduce using rule 51 (expr -> STRING_CONST .)
    *               reduce using rule 51 (expr -> STRING_CONST .)
    -               reduce using rule 51 (expr -> STRING_CONST .)
    +               reduce using rule 51 (expr -> STRING_CONST .)
    DEC             reduce using rule 51 (expr -> STRING_CONST .)
    INC             reduce using rule 51 (expr -> STRING_CONST .)
    MAYOR_IGUAL     reduce using rule 51 (expr -> STRING_CONST .)
    MAYOR_QUE       reduce using rule 51 (expr -> STRING_CONST .)
    MENOR_IGUAL     reduce using rule 51 (expr -> STRING_CONST .)
    MENOR_QUE       reduce using rule 51 (expr -> STRING_CONST .)
    NO_IGUAL        reduce using rule 51 (expr -> STRING_CONST .)
    IGUAL           reduce using rule 51 (expr -> STRING_CONST .)
    AND             reduce using rule 51 (expr -> STRING_CONST .)
    OR              reduce using rule 51 (expr -> STRING_CONST .)
    ]               reduce using rule 51 (expr -> STRING_CONST .)
    ,               reduce using rule 51 (expr -> STRING_CONST .)
    }               reduce using rule 51 (expr -> STRING_CONST .)
    )               reduce using rule 51 (expr -> STRING_CONST .)


state 35

    (52) expr -> CHAR_CONST .
    ;               reduce using rule 52 (expr -> CHAR_CONST .)
    ^               reduce using rule 52 (expr -> CHAR_CONST .)
    %               reduce using rule 52 (expr -> CHAR_CONST .)
    /               reduce using rule 52 (expr -> CHAR_CONST .)
    *               reduce using rule 52 (expr -> CHAR_CONST .)
    -               reduce using rule 52 (expr -> CHAR_CONST .)
    +               reduce using rule 52 (expr -> CHAR_CONST .)
    DEC             reduce using rule 52 (expr -> CHAR_CONST .)
    INC             reduce using rule 52 (expr -> CHAR_CONST .)
    MAYOR_IGUAL     reduce using rule 52 (expr -> CHAR_CONST .)
    MAYOR_QUE       reduce using rule 52 (expr -> CHAR_CONST .)
    MENOR_IGUAL     reduce using rule 52 (expr -> CHAR_CONST .)
    MENOR_QUE       reduce using rule 52 (expr -> CHAR_CONST .)
    NO_IGUAL        reduce using rule 52 (expr -> CHAR_CONST .)
    IGUAL           reduce using rule 52 (expr -> CHAR_CONST .)
    AND             reduce using rule 52 (expr -> CHAR_CONST .)
    OR              reduce using rule 52 (expr -> CHAR_CONST .)
    ]               reduce using rule 52 (expr -> CHAR_CONST .)
    ,               reduce using rule 52 (expr -> CHAR_CONST .)
    }               reduce using rule 52 (expr -> CHAR_CONST .)
    )               reduce using rule 52 (expr -> CHAR_CONST .)


state 36

    (53) expr -> FLOAT_CONST .
    ;               reduce using rule 53 (expr -> FLOAT_CONST .)
    ^               reduce using rule 53 (expr -> FLOAT_CONST .)
    %               reduce using rule 53 (expr -> FLOAT_CONST .)
    /               reduce using rule 53 (expr -> FLOAT_CONST .)
    *               reduce using rule 53 (expr -> FLOAT_CONST .)
    -               reduce using rule 53 (expr -> FLOAT_CONST .)
    +               reduce using rule 53 (expr -> FLOAT_CONST .)
    DEC             reduce using rule 53 (expr -> FLOAT_CONST .)
    INC             reduce using rule 53 (expr -> FLOAT_CONST .)
    MAYOR_IGUAL     reduce using rule 53 (expr -> FLOAT_CONST .)
    MAYOR_QUE       reduce using rule 53 (expr -> FLOAT_CONST .)
    MENOR_IGUAL     reduce using rule 53 (expr -> FLOAT_CONST .)
    MENOR_QUE       reduce using rule 53 (expr -> FLOAT_CONST .)
    NO_IGUAL        reduce using rule 53 (expr -> FLOAT_CONST .)
    IGUAL           reduce using rule 53 (expr -> FLOAT_CONST .)
    AND             reduce using rule 53 (expr -> FLOAT_CONST .)
    OR              reduce using rule 53 (expr -> FLOAT_CONST .)
    ]               reduce using rule 53 (expr -> FLOAT_CONST .)
    ,               reduce using rule 53 (expr -> FLOAT_CONST .)
    }               reduce using rule 53 (expr -> FLOAT_CONST .)
    )               reduce using rule 53 (expr -> FLOAT_CONST .)


state 37

    (54) expr -> INTEGER_CONST .
    ;               reduce using rule 54 (expr -> INTEGER_CONST .)
    ^               reduce using rule 54 (expr -> INTEGER_CONST .)
    %               reduce using rule 54 (expr -> INTEGER_CONST .)
    /               reduce using rule 54 (expr -> INTEGER_CONST .)
    *               reduce using rule 54 (expr -> INTEGER_CONST .)
    -               reduce using rule 54 (expr -> INTEGER_CONST .)
    +               reduce using rule 54 (expr -> INTEGER_CONST .)
    DEC             reduce using rule 54 (expr -> INTEGER_CONST .)
    INC             reduce using rule 54 (expr -> INTEGER_CONST .)
    MAYOR_IGUAL     reduce using rule 54 (expr -> INTEGER_CONST .)
    MAYOR_QUE       reduce using rule 54 (expr -> INTEGER_CONST .)
    MENOR_IGUAL     reduce using rule 54 (expr -> INTEGER_CONST .)
    MENOR_QUE       reduce using rule 54 (expr -> INTEGER_CONST .)
    NO_IGUAL        reduce using rule 54 (expr -> INTEGER_CONST .)
    IGUAL           reduce using rule 54 (expr -> INTEGER_CONST .)
    AND             reduce using rule 54 (expr -> INTEGER_CONST .)
    OR              reduce using rule 54 (expr -> INTEGER_CONST .)
    ]               reduce using rule 54 (expr -> INTEGER_CONST .)
    ,               reduce using rule 54 (expr -> INTEGER_CONST .)
    }               reduce using rule 54 (expr -> INTEGER_CONST .)
    )               reduce using rule 54 (expr -> INTEGER_CONST .)


state 38

    (58) expr -> ( . expr )
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 87
    lval                           shift and go to state 43

state 39

    (59) expr -> DEC . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 88
    lval                           shift and go to state 43

state 40

    (60) expr -> INC . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 89
    lval                           shift and go to state 43

state 41

    (61) expr -> NOT . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 90
    lval                           shift and go to state 43

state 42

    (62) expr -> - . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 91
    lval                           shift and go to state 43

state 43

    (79) expr -> lval . = expr
    =               shift and go to state 92


state 44

    (19) function_type -> FUNCTION type_name ( . opt_param_list )
    (20) opt_param_list -> . param_list
    (21) opt_param_list -> . empty
    (22) param_list -> . param
    (23) param_list -> . param_list , param
    (82) empty -> .
    (24) param -> . ID : array_type
    (25) param -> . ID : type_name
    )               reduce using rule 82 (empty -> .)
    ID              shift and go to state 97

    opt_param_list                 shift and go to state 93
    param_list                     shift and go to state 94
    empty                          shift and go to state 95
    param                          shift and go to state 96

state 45

    (17) array_type -> ARRAY [ expr . ] type_name
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ]               shift and go to state 98
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 46

    (18) array_type -> ARRAY [ ] . type_name
    (11) type_name -> . VOID
    (12) type_name -> . STRING
    (13) type_name -> . CHAR
    (14) type_name -> . BOOLEAN
    (15) type_name -> . FLOAT
    (16) type_name -> . INTEGER
    VOID            shift and go to state 14
    STRING          shift and go to state 15
    CHAR            shift and go to state 16
    BOOLEAN         shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19

    type_name                      shift and go to state 99

state 47

    (55) expr -> ID .
    (56) expr -> ID . [ expr ]
    (57) expr -> ID . ( opt_expr_list )
    (5) decl -> ID . : function_type ;
    (6) decl -> ID . : array_type ;
    (7) decl -> ID . : type_name = expr ;
    (8) decl -> ID . : type_name ;
    (80) lval -> ID . [ expr ]
    (81) lval -> ID .
    (9) decl_init -> ID . : function_type = { opt_stmt_list }
    (10) decl_init -> ID . : array_type = { opt_expr_list } ;
    ;               reduce using rule 55 (expr -> ID .)
    ^               reduce using rule 55 (expr -> ID .)
    %               reduce using rule 55 (expr -> ID .)
    /               reduce using rule 55 (expr -> ID .)
    *               reduce using rule 55 (expr -> ID .)
    -               reduce using rule 55 (expr -> ID .)
    +               reduce using rule 55 (expr -> ID .)
    DEC             reduce using rule 55 (expr -> ID .)
    INC             reduce using rule 55 (expr -> ID .)
    MAYOR_IGUAL     reduce using rule 55 (expr -> ID .)
    MAYOR_QUE       reduce using rule 55 (expr -> ID .)
    MENOR_IGUAL     reduce using rule 55 (expr -> ID .)
    MENOR_QUE       reduce using rule 55 (expr -> ID .)
    NO_IGUAL        reduce using rule 55 (expr -> ID .)
    IGUAL           reduce using rule 55 (expr -> ID .)
    AND             reduce using rule 55 (expr -> ID .)
    OR              reduce using rule 55 (expr -> ID .)
    [               shift and go to state 68
    (               shift and go to state 69
    :               shift and go to state 8
    =               reduce using rule 81 (lval -> ID .)


state 48

    (42) block_stmt -> { . stmt_list }
    (28) stmt_list -> . stmt
    (29) stmt_list -> . stmt stmt_list
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    stmt_list                      shift and go to state 100
    stmt                           shift and go to state 52
    expr                           shift and go to state 53
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 49

    (9) decl_init -> ID : function_type = { opt_stmt_list . }
    }               shift and go to state 101


state 50

    (26) opt_stmt_list -> empty .
    }               reduce using rule 26 (opt_stmt_list -> empty .)


state 51

    (27) opt_stmt_list -> stmt_list .
    }               reduce using rule 27 (opt_stmt_list -> stmt_list .)


state 52

    (28) stmt_list -> stmt .
    (29) stmt_list -> stmt . stmt_list
    (28) stmt_list -> . stmt
    (29) stmt_list -> . stmt stmt_list
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    }               reduce using rule 28 (stmt_list -> stmt .)
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    stmt                           shift and go to state 52
    stmt_list                      shift and go to state 102
    expr                           shift and go to state 53
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 53

    (30) stmt -> expr . ;
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               shift and go to state 103
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 54

    (31) stmt -> decl .
    FOR             reduce using rule 31 (stmt -> decl .)
    IF              reduce using rule 31 (stmt -> decl .)
    DO              reduce using rule 31 (stmt -> decl .)
    WHILE           reduce using rule 31 (stmt -> decl .)
    FALSE           reduce using rule 31 (stmt -> decl .)
    TRUE            reduce using rule 31 (stmt -> decl .)
    STRING_CONST    reduce using rule 31 (stmt -> decl .)
    CHAR_CONST      reduce using rule 31 (stmt -> decl .)
    FLOAT_CONST     reduce using rule 31 (stmt -> decl .)
    INTEGER_CONST   reduce using rule 31 (stmt -> decl .)
    ID              reduce using rule 31 (stmt -> decl .)
    (               reduce using rule 31 (stmt -> decl .)
    DEC             reduce using rule 31 (stmt -> decl .)
    INC             reduce using rule 31 (stmt -> decl .)
    NOT             reduce using rule 31 (stmt -> decl .)
    -               reduce using rule 31 (stmt -> decl .)
    {               reduce using rule 31 (stmt -> decl .)
    RETURN          reduce using rule 31 (stmt -> decl .)
    PRINT           reduce using rule 31 (stmt -> decl .)
    }               reduce using rule 31 (stmt -> decl .)
    ELSE            reduce using rule 31 (stmt -> decl .)


state 55

    (32) stmt -> block_stmt .
    FOR             reduce using rule 32 (stmt -> block_stmt .)
    IF              reduce using rule 32 (stmt -> block_stmt .)
    DO              reduce using rule 32 (stmt -> block_stmt .)
    WHILE           reduce using rule 32 (stmt -> block_stmt .)
    FALSE           reduce using rule 32 (stmt -> block_stmt .)
    TRUE            reduce using rule 32 (stmt -> block_stmt .)
    STRING_CONST    reduce using rule 32 (stmt -> block_stmt .)
    CHAR_CONST      reduce using rule 32 (stmt -> block_stmt .)
    FLOAT_CONST     reduce using rule 32 (stmt -> block_stmt .)
    INTEGER_CONST   reduce using rule 32 (stmt -> block_stmt .)
    ID              reduce using rule 32 (stmt -> block_stmt .)
    (               reduce using rule 32 (stmt -> block_stmt .)
    DEC             reduce using rule 32 (stmt -> block_stmt .)
    INC             reduce using rule 32 (stmt -> block_stmt .)
    NOT             reduce using rule 32 (stmt -> block_stmt .)
    -               reduce using rule 32 (stmt -> block_stmt .)
    {               reduce using rule 32 (stmt -> block_stmt .)
    RETURN          reduce using rule 32 (stmt -> block_stmt .)
    PRINT           reduce using rule 32 (stmt -> block_stmt .)
    }               reduce using rule 32 (stmt -> block_stmt .)
    ELSE            reduce using rule 32 (stmt -> block_stmt .)


state 56

    (33) stmt -> return_stmt .
    FOR             reduce using rule 33 (stmt -> return_stmt .)
    IF              reduce using rule 33 (stmt -> return_stmt .)
    DO              reduce using rule 33 (stmt -> return_stmt .)
    WHILE           reduce using rule 33 (stmt -> return_stmt .)
    FALSE           reduce using rule 33 (stmt -> return_stmt .)
    TRUE            reduce using rule 33 (stmt -> return_stmt .)
    STRING_CONST    reduce using rule 33 (stmt -> return_stmt .)
    CHAR_CONST      reduce using rule 33 (stmt -> return_stmt .)
    FLOAT_CONST     reduce using rule 33 (stmt -> return_stmt .)
    INTEGER_CONST   reduce using rule 33 (stmt -> return_stmt .)
    ID              reduce using rule 33 (stmt -> return_stmt .)
    (               reduce using rule 33 (stmt -> return_stmt .)
    DEC             reduce using rule 33 (stmt -> return_stmt .)
    INC             reduce using rule 33 (stmt -> return_stmt .)
    NOT             reduce using rule 33 (stmt -> return_stmt .)
    -               reduce using rule 33 (stmt -> return_stmt .)
    {               reduce using rule 33 (stmt -> return_stmt .)
    RETURN          reduce using rule 33 (stmt -> return_stmt .)
    PRINT           reduce using rule 33 (stmt -> return_stmt .)
    }               reduce using rule 33 (stmt -> return_stmt .)
    ELSE            reduce using rule 33 (stmt -> return_stmt .)


state 57

    (34) stmt -> print_stmt .
    FOR             reduce using rule 34 (stmt -> print_stmt .)
    IF              reduce using rule 34 (stmt -> print_stmt .)
    DO              reduce using rule 34 (stmt -> print_stmt .)
    WHILE           reduce using rule 34 (stmt -> print_stmt .)
    FALSE           reduce using rule 34 (stmt -> print_stmt .)
    TRUE            reduce using rule 34 (stmt -> print_stmt .)
    STRING_CONST    reduce using rule 34 (stmt -> print_stmt .)
    CHAR_CONST      reduce using rule 34 (stmt -> print_stmt .)
    FLOAT_CONST     reduce using rule 34 (stmt -> print_stmt .)
    INTEGER_CONST   reduce using rule 34 (stmt -> print_stmt .)
    ID              reduce using rule 34 (stmt -> print_stmt .)
    (               reduce using rule 34 (stmt -> print_stmt .)
    DEC             reduce using rule 34 (stmt -> print_stmt .)
    INC             reduce using rule 34 (stmt -> print_stmt .)
    NOT             reduce using rule 34 (stmt -> print_stmt .)
    -               reduce using rule 34 (stmt -> print_stmt .)
    {               reduce using rule 34 (stmt -> print_stmt .)
    RETURN          reduce using rule 34 (stmt -> print_stmt .)
    PRINT           reduce using rule 34 (stmt -> print_stmt .)
    }               reduce using rule 34 (stmt -> print_stmt .)
    ELSE            reduce using rule 34 (stmt -> print_stmt .)


state 58

    (35) stmt -> FOR . ( opt_expr ; opt_expr ; opt_expr ) stmt
    (               shift and go to state 104


state 59

    (36) stmt -> IF . ( expr ) stmt ELSE stmt
    (37) stmt -> IF . ( expr ) stmt
    (               shift and go to state 105


state 60

    (38) stmt -> DO . stmt WHILE ( expr ) ;
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    stmt                           shift and go to state 106
    expr                           shift and go to state 53
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 61

    (39) stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 107


state 62

    (41) return_stmt -> RETURN . opt_expr ;
    (47) opt_expr -> . expr
    (48) opt_expr -> . empty
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (82) empty -> .
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    ;               reduce using rule 82 (empty -> .)

    opt_expr                       shift and go to state 108
    expr                           shift and go to state 109
    empty                          shift and go to state 110
    lval                           shift and go to state 43

state 63

    (40) print_stmt -> PRINT . opt_expr_list ;
    (43) opt_expr_list -> . expr_list
    (44) opt_expr_list -> . empty
    (45) expr_list -> . expr
    (46) expr_list -> . expr , expr_list
    (82) empty -> .
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    ;               reduce using rule 82 (empty -> .)
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    opt_expr_list                  shift and go to state 111
    expr_list                      shift and go to state 65
    empty                          shift and go to state 66
    expr                           shift and go to state 67
    lval                           shift and go to state 43

state 64

    (10) decl_init -> ID : array_type = { opt_expr_list . } ;
    }               shift and go to state 112


state 65

    (43) opt_expr_list -> expr_list .
    }               reduce using rule 43 (opt_expr_list -> expr_list .)
    ;               reduce using rule 43 (opt_expr_list -> expr_list .)
    )               reduce using rule 43 (opt_expr_list -> expr_list .)


state 66

    (44) opt_expr_list -> empty .
    }               reduce using rule 44 (opt_expr_list -> empty .)
    ;               reduce using rule 44 (opt_expr_list -> empty .)
    )               reduce using rule 44 (opt_expr_list -> empty .)


state 67

    (45) expr_list -> expr .
    (46) expr_list -> expr . , expr_list
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    }               reduce using rule 45 (expr_list -> expr .)
    ;               reduce using rule 45 (expr_list -> expr .)
    )               reduce using rule 45 (expr_list -> expr .)
    ,               shift and go to state 113
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 68

    (56) expr -> ID [ . expr ]
    (80) lval -> ID [ . expr ]
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 114
    lval                           shift and go to state 43

state 69

    (57) expr -> ID ( . opt_expr_list )
    (43) opt_expr_list -> . expr_list
    (44) opt_expr_list -> . empty
    (45) expr_list -> . expr
    (46) expr_list -> . expr , expr_list
    (82) empty -> .
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    )               reduce using rule 82 (empty -> .)
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    opt_expr_list                  shift and go to state 115
    expr_list                      shift and go to state 65
    empty                          shift and go to state 66
    expr                           shift and go to state 67
    lval                           shift and go to state 43

state 70

    (7) decl -> ID : type_name = expr ; .
    ID              reduce using rule 7 (decl -> ID : type_name = expr ; .)
    $end            reduce using rule 7 (decl -> ID : type_name = expr ; .)
    FOR             reduce using rule 7 (decl -> ID : type_name = expr ; .)
    IF              reduce using rule 7 (decl -> ID : type_name = expr ; .)
    DO              reduce using rule 7 (decl -> ID : type_name = expr ; .)
    WHILE           reduce using rule 7 (decl -> ID : type_name = expr ; .)
    FALSE           reduce using rule 7 (decl -> ID : type_name = expr ; .)
    TRUE            reduce using rule 7 (decl -> ID : type_name = expr ; .)
    STRING_CONST    reduce using rule 7 (decl -> ID : type_name = expr ; .)
    CHAR_CONST      reduce using rule 7 (decl -> ID : type_name = expr ; .)
    FLOAT_CONST     reduce using rule 7 (decl -> ID : type_name = expr ; .)
    INTEGER_CONST   reduce using rule 7 (decl -> ID : type_name = expr ; .)
    (               reduce using rule 7 (decl -> ID : type_name = expr ; .)
    DEC             reduce using rule 7 (decl -> ID : type_name = expr ; .)
    INC             reduce using rule 7 (decl -> ID : type_name = expr ; .)
    NOT             reduce using rule 7 (decl -> ID : type_name = expr ; .)
    -               reduce using rule 7 (decl -> ID : type_name = expr ; .)
    {               reduce using rule 7 (decl -> ID : type_name = expr ; .)
    RETURN          reduce using rule 7 (decl -> ID : type_name = expr ; .)
    PRINT           reduce using rule 7 (decl -> ID : type_name = expr ; .)
    }               reduce using rule 7 (decl -> ID : type_name = expr ; .)
    ELSE            reduce using rule 7 (decl -> ID : type_name = expr ; .)


state 71

    (63) expr -> expr ^ . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 116
    lval                           shift and go to state 43

state 72

    (64) expr -> expr % . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 117
    lval                           shift and go to state 43

state 73

    (65) expr -> expr / . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 118
    lval                           shift and go to state 43

state 74

    (66) expr -> expr * . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 119
    lval                           shift and go to state 43

state 75

    (67) expr -> expr - . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 120
    lval                           shift and go to state 43

state 76

    (68) expr -> expr + . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 121
    lval                           shift and go to state 43

state 77

    (69) expr -> expr DEC .
    ;               reduce using rule 69 (expr -> expr DEC .)
    ^               reduce using rule 69 (expr -> expr DEC .)
    %               reduce using rule 69 (expr -> expr DEC .)
    /               reduce using rule 69 (expr -> expr DEC .)
    *               reduce using rule 69 (expr -> expr DEC .)
    -               reduce using rule 69 (expr -> expr DEC .)
    +               reduce using rule 69 (expr -> expr DEC .)
    DEC             reduce using rule 69 (expr -> expr DEC .)
    INC             reduce using rule 69 (expr -> expr DEC .)
    MAYOR_IGUAL     reduce using rule 69 (expr -> expr DEC .)
    MAYOR_QUE       reduce using rule 69 (expr -> expr DEC .)
    MENOR_IGUAL     reduce using rule 69 (expr -> expr DEC .)
    MENOR_QUE       reduce using rule 69 (expr -> expr DEC .)
    NO_IGUAL        reduce using rule 69 (expr -> expr DEC .)
    IGUAL           reduce using rule 69 (expr -> expr DEC .)
    AND             reduce using rule 69 (expr -> expr DEC .)
    OR              reduce using rule 69 (expr -> expr DEC .)
    ]               reduce using rule 69 (expr -> expr DEC .)
    ,               reduce using rule 69 (expr -> expr DEC .)
    }               reduce using rule 69 (expr -> expr DEC .)
    )               reduce using rule 69 (expr -> expr DEC .)


state 78

    (70) expr -> expr INC .
    ;               reduce using rule 70 (expr -> expr INC .)
    ^               reduce using rule 70 (expr -> expr INC .)
    %               reduce using rule 70 (expr -> expr INC .)
    /               reduce using rule 70 (expr -> expr INC .)
    *               reduce using rule 70 (expr -> expr INC .)
    -               reduce using rule 70 (expr -> expr INC .)
    +               reduce using rule 70 (expr -> expr INC .)
    DEC             reduce using rule 70 (expr -> expr INC .)
    INC             reduce using rule 70 (expr -> expr INC .)
    MAYOR_IGUAL     reduce using rule 70 (expr -> expr INC .)
    MAYOR_QUE       reduce using rule 70 (expr -> expr INC .)
    MENOR_IGUAL     reduce using rule 70 (expr -> expr INC .)
    MENOR_QUE       reduce using rule 70 (expr -> expr INC .)
    NO_IGUAL        reduce using rule 70 (expr -> expr INC .)
    IGUAL           reduce using rule 70 (expr -> expr INC .)
    AND             reduce using rule 70 (expr -> expr INC .)
    OR              reduce using rule 70 (expr -> expr INC .)
    ]               reduce using rule 70 (expr -> expr INC .)
    ,               reduce using rule 70 (expr -> expr INC .)
    }               reduce using rule 70 (expr -> expr INC .)
    )               reduce using rule 70 (expr -> expr INC .)


state 79

    (71) expr -> expr MAYOR_IGUAL . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 122
    lval                           shift and go to state 43

state 80

    (72) expr -> expr MAYOR_QUE . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 123
    lval                           shift and go to state 43

state 81

    (73) expr -> expr MENOR_IGUAL . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 124
    lval                           shift and go to state 43

state 82

    (74) expr -> expr MENOR_QUE . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 125
    lval                           shift and go to state 43

state 83

    (75) expr -> expr NO_IGUAL . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 126
    lval                           shift and go to state 43

state 84

    (76) expr -> expr IGUAL . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 127
    lval                           shift and go to state 43

state 85

    (77) expr -> expr AND . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 128
    lval                           shift and go to state 43

state 86

    (78) expr -> expr OR . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 129
    lval                           shift and go to state 43

state 87

    (58) expr -> ( expr . )
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 130
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 88

    (59) expr -> DEC expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 59 (expr -> DEC expr .)
    ^               reduce using rule 59 (expr -> DEC expr .)
    %               reduce using rule 59 (expr -> DEC expr .)
    /               reduce using rule 59 (expr -> DEC expr .)
    *               reduce using rule 59 (expr -> DEC expr .)
    -               reduce using rule 59 (expr -> DEC expr .)
    +               reduce using rule 59 (expr -> DEC expr .)
    DEC             reduce using rule 59 (expr -> DEC expr .)
    INC             reduce using rule 59 (expr -> DEC expr .)
    MAYOR_IGUAL     reduce using rule 59 (expr -> DEC expr .)
    MAYOR_QUE       reduce using rule 59 (expr -> DEC expr .)
    MENOR_IGUAL     reduce using rule 59 (expr -> DEC expr .)
    MENOR_QUE       reduce using rule 59 (expr -> DEC expr .)
    NO_IGUAL        reduce using rule 59 (expr -> DEC expr .)
    IGUAL           reduce using rule 59 (expr -> DEC expr .)
    AND             reduce using rule 59 (expr -> DEC expr .)
    OR              reduce using rule 59 (expr -> DEC expr .)
    ]               reduce using rule 59 (expr -> DEC expr .)
    ,               reduce using rule 59 (expr -> DEC expr .)
    }               reduce using rule 59 (expr -> DEC expr .)
    )               reduce using rule 59 (expr -> DEC expr .)


state 89

    (60) expr -> INC expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 60 (expr -> INC expr .)
    ^               reduce using rule 60 (expr -> INC expr .)
    %               reduce using rule 60 (expr -> INC expr .)
    /               reduce using rule 60 (expr -> INC expr .)
    *               reduce using rule 60 (expr -> INC expr .)
    -               reduce using rule 60 (expr -> INC expr .)
    +               reduce using rule 60 (expr -> INC expr .)
    DEC             reduce using rule 60 (expr -> INC expr .)
    INC             reduce using rule 60 (expr -> INC expr .)
    MAYOR_IGUAL     reduce using rule 60 (expr -> INC expr .)
    MAYOR_QUE       reduce using rule 60 (expr -> INC expr .)
    MENOR_IGUAL     reduce using rule 60 (expr -> INC expr .)
    MENOR_QUE       reduce using rule 60 (expr -> INC expr .)
    NO_IGUAL        reduce using rule 60 (expr -> INC expr .)
    IGUAL           reduce using rule 60 (expr -> INC expr .)
    AND             reduce using rule 60 (expr -> INC expr .)
    OR              reduce using rule 60 (expr -> INC expr .)
    ]               reduce using rule 60 (expr -> INC expr .)
    ,               reduce using rule 60 (expr -> INC expr .)
    }               reduce using rule 60 (expr -> INC expr .)
    )               reduce using rule 60 (expr -> INC expr .)


state 90

    (61) expr -> NOT expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 61 (expr -> NOT expr .)
    ^               reduce using rule 61 (expr -> NOT expr .)
    %               reduce using rule 61 (expr -> NOT expr .)
    /               reduce using rule 61 (expr -> NOT expr .)
    *               reduce using rule 61 (expr -> NOT expr .)
    -               reduce using rule 61 (expr -> NOT expr .)
    +               reduce using rule 61 (expr -> NOT expr .)
    DEC             reduce using rule 61 (expr -> NOT expr .)
    INC             reduce using rule 61 (expr -> NOT expr .)
    MAYOR_IGUAL     reduce using rule 61 (expr -> NOT expr .)
    MAYOR_QUE       reduce using rule 61 (expr -> NOT expr .)
    MENOR_IGUAL     reduce using rule 61 (expr -> NOT expr .)
    MENOR_QUE       reduce using rule 61 (expr -> NOT expr .)
    NO_IGUAL        reduce using rule 61 (expr -> NOT expr .)
    IGUAL           reduce using rule 61 (expr -> NOT expr .)
    AND             reduce using rule 61 (expr -> NOT expr .)
    OR              reduce using rule 61 (expr -> NOT expr .)
    ]               reduce using rule 61 (expr -> NOT expr .)
    ,               reduce using rule 61 (expr -> NOT expr .)
    }               reduce using rule 61 (expr -> NOT expr .)
    )               reduce using rule 61 (expr -> NOT expr .)


state 91

    (62) expr -> - expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> - expr .)
    ^               reduce using rule 62 (expr -> - expr .)
    %               reduce using rule 62 (expr -> - expr .)
    /               reduce using rule 62 (expr -> - expr .)
    *               reduce using rule 62 (expr -> - expr .)
    -               reduce using rule 62 (expr -> - expr .)
    +               reduce using rule 62 (expr -> - expr .)
    DEC             reduce using rule 62 (expr -> - expr .)
    INC             reduce using rule 62 (expr -> - expr .)
    MAYOR_IGUAL     reduce using rule 62 (expr -> - expr .)
    MAYOR_QUE       reduce using rule 62 (expr -> - expr .)
    MENOR_IGUAL     reduce using rule 62 (expr -> - expr .)
    MENOR_QUE       reduce using rule 62 (expr -> - expr .)
    NO_IGUAL        reduce using rule 62 (expr -> - expr .)
    IGUAL           reduce using rule 62 (expr -> - expr .)
    AND             reduce using rule 62 (expr -> - expr .)
    OR              reduce using rule 62 (expr -> - expr .)
    ]               reduce using rule 62 (expr -> - expr .)
    ,               reduce using rule 62 (expr -> - expr .)
    }               reduce using rule 62 (expr -> - expr .)
    )               reduce using rule 62 (expr -> - expr .)


state 92

    (79) expr -> lval = . expr
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    lval                           shift and go to state 43
    expr                           shift and go to state 131

state 93

    (19) function_type -> FUNCTION type_name ( opt_param_list . )
    )               shift and go to state 132


state 94

    (20) opt_param_list -> param_list .
    (23) param_list -> param_list . , param
    )               reduce using rule 20 (opt_param_list -> param_list .)
    ,               shift and go to state 133


state 95

    (21) opt_param_list -> empty .
    )               reduce using rule 21 (opt_param_list -> empty .)


state 96

    (22) param_list -> param .
    ,               reduce using rule 22 (param_list -> param .)
    )               reduce using rule 22 (param_list -> param .)


state 97

    (24) param -> ID . : array_type
    (25) param -> ID . : type_name
    :               shift and go to state 134


state 98

    (17) array_type -> ARRAY [ expr ] . type_name
    (11) type_name -> . VOID
    (12) type_name -> . STRING
    (13) type_name -> . CHAR
    (14) type_name -> . BOOLEAN
    (15) type_name -> . FLOAT
    (16) type_name -> . INTEGER
    VOID            shift and go to state 14
    STRING          shift and go to state 15
    CHAR            shift and go to state 16
    BOOLEAN         shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19

    type_name                      shift and go to state 135

state 99

    (18) array_type -> ARRAY [ ] type_name .
    ;               reduce using rule 18 (array_type -> ARRAY [ ] type_name .)
    =               reduce using rule 18 (array_type -> ARRAY [ ] type_name .)
    ,               reduce using rule 18 (array_type -> ARRAY [ ] type_name .)
    )               reduce using rule 18 (array_type -> ARRAY [ ] type_name .)


state 100

    (42) block_stmt -> { stmt_list . }
    }               shift and go to state 136


state 101

    (9) decl_init -> ID : function_type = { opt_stmt_list } .
    ID              reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    $end            reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    FOR             reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    IF              reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    DO              reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    WHILE           reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    FALSE           reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    TRUE            reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    STRING_CONST    reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    CHAR_CONST      reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    FLOAT_CONST     reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    INTEGER_CONST   reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    (               reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    DEC             reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    INC             reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    NOT             reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    -               reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    {               reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    RETURN          reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    PRINT           reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    }               reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)
    ELSE            reduce using rule 9 (decl_init -> ID : function_type = { opt_stmt_list } .)


state 102

    (29) stmt_list -> stmt stmt_list .
    }               reduce using rule 29 (stmt_list -> stmt stmt_list .)


state 103

    (30) stmt -> expr ; .
    FOR             reduce using rule 30 (stmt -> expr ; .)
    IF              reduce using rule 30 (stmt -> expr ; .)
    DO              reduce using rule 30 (stmt -> expr ; .)
    WHILE           reduce using rule 30 (stmt -> expr ; .)
    FALSE           reduce using rule 30 (stmt -> expr ; .)
    TRUE            reduce using rule 30 (stmt -> expr ; .)
    STRING_CONST    reduce using rule 30 (stmt -> expr ; .)
    CHAR_CONST      reduce using rule 30 (stmt -> expr ; .)
    FLOAT_CONST     reduce using rule 30 (stmt -> expr ; .)
    INTEGER_CONST   reduce using rule 30 (stmt -> expr ; .)
    ID              reduce using rule 30 (stmt -> expr ; .)
    (               reduce using rule 30 (stmt -> expr ; .)
    DEC             reduce using rule 30 (stmt -> expr ; .)
    INC             reduce using rule 30 (stmt -> expr ; .)
    NOT             reduce using rule 30 (stmt -> expr ; .)
    -               reduce using rule 30 (stmt -> expr ; .)
    {               reduce using rule 30 (stmt -> expr ; .)
    RETURN          reduce using rule 30 (stmt -> expr ; .)
    PRINT           reduce using rule 30 (stmt -> expr ; .)
    }               reduce using rule 30 (stmt -> expr ; .)
    ELSE            reduce using rule 30 (stmt -> expr ; .)


state 104

    (35) stmt -> FOR ( . opt_expr ; opt_expr ; opt_expr ) stmt
    (47) opt_expr -> . expr
    (48) opt_expr -> . empty
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (82) empty -> .
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    ;               reduce using rule 82 (empty -> .)

    opt_expr                       shift and go to state 137
    expr                           shift and go to state 109
    empty                          shift and go to state 110
    lval                           shift and go to state 43

state 105

    (36) stmt -> IF ( . expr ) stmt ELSE stmt
    (37) stmt -> IF ( . expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 138
    lval                           shift and go to state 43

state 106

    (38) stmt -> DO stmt . WHILE ( expr ) ;
    WHILE           shift and go to state 139


state 107

    (39) stmt -> WHILE ( . expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 140
    lval                           shift and go to state 43

state 108

    (41) return_stmt -> RETURN opt_expr . ;
    ;               shift and go to state 141


state 109

    (47) opt_expr -> expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 47 (opt_expr -> expr .)
    )               reduce using rule 47 (opt_expr -> expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 110

    (48) opt_expr -> empty .
    ;               reduce using rule 48 (opt_expr -> empty .)
    )               reduce using rule 48 (opt_expr -> empty .)


state 111

    (40) print_stmt -> PRINT opt_expr_list . ;
    ;               shift and go to state 142


state 112

    (10) decl_init -> ID : array_type = { opt_expr_list } . ;
    ;               shift and go to state 143


state 113

    (46) expr_list -> expr , . expr_list
    (45) expr_list -> . expr
    (46) expr_list -> . expr , expr_list
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 67
    expr_list                      shift and go to state 144
    lval                           shift and go to state 43

state 114

    (56) expr -> ID [ expr . ]
    (80) lval -> ID [ expr . ]
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ]               shift and go to state 145
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 115

    (57) expr -> ID ( opt_expr_list . )
    )               shift and go to state 146


state 116

    (63) expr -> expr ^ expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> expr ^ expr .)
    %               reduce using rule 63 (expr -> expr ^ expr .)
    /               reduce using rule 63 (expr -> expr ^ expr .)
    *               reduce using rule 63 (expr -> expr ^ expr .)
    -               reduce using rule 63 (expr -> expr ^ expr .)
    +               reduce using rule 63 (expr -> expr ^ expr .)
    DEC             reduce using rule 63 (expr -> expr ^ expr .)
    INC             reduce using rule 63 (expr -> expr ^ expr .)
    MAYOR_IGUAL     reduce using rule 63 (expr -> expr ^ expr .)
    MAYOR_QUE       reduce using rule 63 (expr -> expr ^ expr .)
    MENOR_IGUAL     reduce using rule 63 (expr -> expr ^ expr .)
    MENOR_QUE       reduce using rule 63 (expr -> expr ^ expr .)
    NO_IGUAL        reduce using rule 63 (expr -> expr ^ expr .)
    IGUAL           reduce using rule 63 (expr -> expr ^ expr .)
    AND             reduce using rule 63 (expr -> expr ^ expr .)
    OR              reduce using rule 63 (expr -> expr ^ expr .)
    ]               reduce using rule 63 (expr -> expr ^ expr .)
    ,               reduce using rule 63 (expr -> expr ^ expr .)
    }               reduce using rule 63 (expr -> expr ^ expr .)
    )               reduce using rule 63 (expr -> expr ^ expr .)
    ^               shift and go to state 71


state 117

    (64) expr -> expr % expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> expr % expr .)
    %               reduce using rule 64 (expr -> expr % expr .)
    /               reduce using rule 64 (expr -> expr % expr .)
    *               reduce using rule 64 (expr -> expr % expr .)
    -               reduce using rule 64 (expr -> expr % expr .)
    +               reduce using rule 64 (expr -> expr % expr .)
    DEC             reduce using rule 64 (expr -> expr % expr .)
    INC             reduce using rule 64 (expr -> expr % expr .)
    MAYOR_IGUAL     reduce using rule 64 (expr -> expr % expr .)
    MAYOR_QUE       reduce using rule 64 (expr -> expr % expr .)
    MENOR_IGUAL     reduce using rule 64 (expr -> expr % expr .)
    MENOR_QUE       reduce using rule 64 (expr -> expr % expr .)
    NO_IGUAL        reduce using rule 64 (expr -> expr % expr .)
    IGUAL           reduce using rule 64 (expr -> expr % expr .)
    AND             reduce using rule 64 (expr -> expr % expr .)
    OR              reduce using rule 64 (expr -> expr % expr .)
    ]               reduce using rule 64 (expr -> expr % expr .)
    ,               reduce using rule 64 (expr -> expr % expr .)
    }               reduce using rule 64 (expr -> expr % expr .)
    )               reduce using rule 64 (expr -> expr % expr .)
    ^               shift and go to state 71


state 118

    (65) expr -> expr / expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> expr / expr .)
    %               reduce using rule 65 (expr -> expr / expr .)
    /               reduce using rule 65 (expr -> expr / expr .)
    *               reduce using rule 65 (expr -> expr / expr .)
    -               reduce using rule 65 (expr -> expr / expr .)
    +               reduce using rule 65 (expr -> expr / expr .)
    DEC             reduce using rule 65 (expr -> expr / expr .)
    INC             reduce using rule 65 (expr -> expr / expr .)
    MAYOR_IGUAL     reduce using rule 65 (expr -> expr / expr .)
    MAYOR_QUE       reduce using rule 65 (expr -> expr / expr .)
    MENOR_IGUAL     reduce using rule 65 (expr -> expr / expr .)
    MENOR_QUE       reduce using rule 65 (expr -> expr / expr .)
    NO_IGUAL        reduce using rule 65 (expr -> expr / expr .)
    IGUAL           reduce using rule 65 (expr -> expr / expr .)
    AND             reduce using rule 65 (expr -> expr / expr .)
    OR              reduce using rule 65 (expr -> expr / expr .)
    ]               reduce using rule 65 (expr -> expr / expr .)
    ,               reduce using rule 65 (expr -> expr / expr .)
    }               reduce using rule 65 (expr -> expr / expr .)
    )               reduce using rule 65 (expr -> expr / expr .)
    ^               shift and go to state 71


state 119

    (66) expr -> expr * expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr * expr .)
    %               reduce using rule 66 (expr -> expr * expr .)
    /               reduce using rule 66 (expr -> expr * expr .)
    *               reduce using rule 66 (expr -> expr * expr .)
    -               reduce using rule 66 (expr -> expr * expr .)
    +               reduce using rule 66 (expr -> expr * expr .)
    DEC             reduce using rule 66 (expr -> expr * expr .)
    INC             reduce using rule 66 (expr -> expr * expr .)
    MAYOR_IGUAL     reduce using rule 66 (expr -> expr * expr .)
    MAYOR_QUE       reduce using rule 66 (expr -> expr * expr .)
    MENOR_IGUAL     reduce using rule 66 (expr -> expr * expr .)
    MENOR_QUE       reduce using rule 66 (expr -> expr * expr .)
    NO_IGUAL        reduce using rule 66 (expr -> expr * expr .)
    IGUAL           reduce using rule 66 (expr -> expr * expr .)
    AND             reduce using rule 66 (expr -> expr * expr .)
    OR              reduce using rule 66 (expr -> expr * expr .)
    ]               reduce using rule 66 (expr -> expr * expr .)
    ,               reduce using rule 66 (expr -> expr * expr .)
    }               reduce using rule 66 (expr -> expr * expr .)
    )               reduce using rule 66 (expr -> expr * expr .)
    ^               shift and go to state 71


state 120

    (67) expr -> expr - expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr - expr .)
    -               reduce using rule 67 (expr -> expr - expr .)
    +               reduce using rule 67 (expr -> expr - expr .)
    DEC             reduce using rule 67 (expr -> expr - expr .)
    INC             reduce using rule 67 (expr -> expr - expr .)
    MAYOR_IGUAL     reduce using rule 67 (expr -> expr - expr .)
    MAYOR_QUE       reduce using rule 67 (expr -> expr - expr .)
    MENOR_IGUAL     reduce using rule 67 (expr -> expr - expr .)
    MENOR_QUE       reduce using rule 67 (expr -> expr - expr .)
    NO_IGUAL        reduce using rule 67 (expr -> expr - expr .)
    IGUAL           reduce using rule 67 (expr -> expr - expr .)
    AND             reduce using rule 67 (expr -> expr - expr .)
    OR              reduce using rule 67 (expr -> expr - expr .)
    ]               reduce using rule 67 (expr -> expr - expr .)
    ,               reduce using rule 67 (expr -> expr - expr .)
    }               reduce using rule 67 (expr -> expr - expr .)
    )               reduce using rule 67 (expr -> expr - expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74


state 121

    (68) expr -> expr + expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr + expr .)
    -               reduce using rule 68 (expr -> expr + expr .)
    +               reduce using rule 68 (expr -> expr + expr .)
    DEC             reduce using rule 68 (expr -> expr + expr .)
    INC             reduce using rule 68 (expr -> expr + expr .)
    MAYOR_IGUAL     reduce using rule 68 (expr -> expr + expr .)
    MAYOR_QUE       reduce using rule 68 (expr -> expr + expr .)
    MENOR_IGUAL     reduce using rule 68 (expr -> expr + expr .)
    MENOR_QUE       reduce using rule 68 (expr -> expr + expr .)
    NO_IGUAL        reduce using rule 68 (expr -> expr + expr .)
    IGUAL           reduce using rule 68 (expr -> expr + expr .)
    AND             reduce using rule 68 (expr -> expr + expr .)
    OR              reduce using rule 68 (expr -> expr + expr .)
    ]               reduce using rule 68 (expr -> expr + expr .)
    ,               reduce using rule 68 (expr -> expr + expr .)
    }               reduce using rule 68 (expr -> expr + expr .)
    )               reduce using rule 68 (expr -> expr + expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74


state 122

    (71) expr -> expr MAYOR_IGUAL expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    DEC             reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    INC             reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    MAYOR_IGUAL     reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    MAYOR_QUE       reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    MENOR_IGUAL     reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    MENOR_QUE       reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    NO_IGUAL        reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    IGUAL           reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    AND             reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    OR              reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    ]               reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    ,               reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    }               reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    )               reduce using rule 71 (expr -> expr MAYOR_IGUAL expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76


state 123

    (72) expr -> expr MAYOR_QUE expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    DEC             reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    INC             reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    MAYOR_IGUAL     reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    MAYOR_QUE       reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    MENOR_IGUAL     reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    MENOR_QUE       reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    NO_IGUAL        reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    IGUAL           reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    AND             reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    OR              reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    ]               reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    ,               reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    }               reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    )               reduce using rule 72 (expr -> expr MAYOR_QUE expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76


state 124

    (73) expr -> expr MENOR_IGUAL expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    DEC             reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    INC             reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    MAYOR_IGUAL     reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    MAYOR_QUE       reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    MENOR_IGUAL     reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    MENOR_QUE       reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    NO_IGUAL        reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    IGUAL           reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    AND             reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    OR              reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    ]               reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    ,               reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    }               reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    )               reduce using rule 73 (expr -> expr MENOR_IGUAL expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76


state 125

    (74) expr -> expr MENOR_QUE expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    DEC             reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    INC             reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    MAYOR_IGUAL     reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    MAYOR_QUE       reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    MENOR_IGUAL     reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    MENOR_QUE       reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    NO_IGUAL        reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    IGUAL           reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    AND             reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    OR              reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    ]               reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    ,               reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    }               reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    )               reduce using rule 74 (expr -> expr MENOR_QUE expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76


state 126

    (75) expr -> expr NO_IGUAL expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    DEC             reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    INC             reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    MAYOR_IGUAL     reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    MAYOR_QUE       reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    MENOR_IGUAL     reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    MENOR_QUE       reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    NO_IGUAL        reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    IGUAL           reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    AND             reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    OR              reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    ]               reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    ,               reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    }               reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    )               reduce using rule 75 (expr -> expr NO_IGUAL expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76


state 127

    (76) expr -> expr IGUAL expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 76 (expr -> expr IGUAL expr .)
    DEC             reduce using rule 76 (expr -> expr IGUAL expr .)
    INC             reduce using rule 76 (expr -> expr IGUAL expr .)
    MAYOR_IGUAL     reduce using rule 76 (expr -> expr IGUAL expr .)
    MAYOR_QUE       reduce using rule 76 (expr -> expr IGUAL expr .)
    MENOR_IGUAL     reduce using rule 76 (expr -> expr IGUAL expr .)
    MENOR_QUE       reduce using rule 76 (expr -> expr IGUAL expr .)
    NO_IGUAL        reduce using rule 76 (expr -> expr IGUAL expr .)
    IGUAL           reduce using rule 76 (expr -> expr IGUAL expr .)
    AND             reduce using rule 76 (expr -> expr IGUAL expr .)
    OR              reduce using rule 76 (expr -> expr IGUAL expr .)
    ]               reduce using rule 76 (expr -> expr IGUAL expr .)
    ,               reduce using rule 76 (expr -> expr IGUAL expr .)
    }               reduce using rule 76 (expr -> expr IGUAL expr .)
    )               reduce using rule 76 (expr -> expr IGUAL expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76


state 128

    (77) expr -> expr AND expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 77 (expr -> expr AND expr .)
    DEC             reduce using rule 77 (expr -> expr AND expr .)
    INC             reduce using rule 77 (expr -> expr AND expr .)
    AND             reduce using rule 77 (expr -> expr AND expr .)
    OR              reduce using rule 77 (expr -> expr AND expr .)
    ]               reduce using rule 77 (expr -> expr AND expr .)
    ,               reduce using rule 77 (expr -> expr AND expr .)
    }               reduce using rule 77 (expr -> expr AND expr .)
    )               reduce using rule 77 (expr -> expr AND expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84


state 129

    (78) expr -> expr OR expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 78 (expr -> expr OR expr .)
    DEC             reduce using rule 78 (expr -> expr OR expr .)
    INC             reduce using rule 78 (expr -> expr OR expr .)
    OR              reduce using rule 78 (expr -> expr OR expr .)
    ]               reduce using rule 78 (expr -> expr OR expr .)
    ,               reduce using rule 78 (expr -> expr OR expr .)
    }               reduce using rule 78 (expr -> expr OR expr .)
    )               reduce using rule 78 (expr -> expr OR expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85


state 130

    (58) expr -> ( expr ) .
    ;               reduce using rule 58 (expr -> ( expr ) .)
    ^               reduce using rule 58 (expr -> ( expr ) .)
    %               reduce using rule 58 (expr -> ( expr ) .)
    /               reduce using rule 58 (expr -> ( expr ) .)
    *               reduce using rule 58 (expr -> ( expr ) .)
    -               reduce using rule 58 (expr -> ( expr ) .)
    +               reduce using rule 58 (expr -> ( expr ) .)
    DEC             reduce using rule 58 (expr -> ( expr ) .)
    INC             reduce using rule 58 (expr -> ( expr ) .)
    MAYOR_IGUAL     reduce using rule 58 (expr -> ( expr ) .)
    MAYOR_QUE       reduce using rule 58 (expr -> ( expr ) .)
    MENOR_IGUAL     reduce using rule 58 (expr -> ( expr ) .)
    MENOR_QUE       reduce using rule 58 (expr -> ( expr ) .)
    NO_IGUAL        reduce using rule 58 (expr -> ( expr ) .)
    IGUAL           reduce using rule 58 (expr -> ( expr ) .)
    AND             reduce using rule 58 (expr -> ( expr ) .)
    OR              reduce using rule 58 (expr -> ( expr ) .)
    ]               reduce using rule 58 (expr -> ( expr ) .)
    ,               reduce using rule 58 (expr -> ( expr ) .)
    }               reduce using rule 58 (expr -> ( expr ) .)
    )               reduce using rule 58 (expr -> ( expr ) .)


state 131

    (79) expr -> lval = expr .
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    ;               reduce using rule 79 (expr -> lval = expr .)
    DEC             reduce using rule 79 (expr -> lval = expr .)
    INC             reduce using rule 79 (expr -> lval = expr .)
    ]               reduce using rule 79 (expr -> lval = expr .)
    ,               reduce using rule 79 (expr -> lval = expr .)
    }               reduce using rule 79 (expr -> lval = expr .)
    )               reduce using rule 79 (expr -> lval = expr .)
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 132

    (19) function_type -> FUNCTION type_name ( opt_param_list ) .
    ;               reduce using rule 19 (function_type -> FUNCTION type_name ( opt_param_list ) .)
    =               reduce using rule 19 (function_type -> FUNCTION type_name ( opt_param_list ) .)


state 133

    (23) param_list -> param_list , . param
    (24) param -> . ID : array_type
    (25) param -> . ID : type_name
    ID              shift and go to state 97

    param                          shift and go to state 147

state 134

    (24) param -> ID : . array_type
    (25) param -> ID : . type_name
    (17) array_type -> . ARRAY [ expr ] type_name
    (18) array_type -> . ARRAY [ ] type_name
    (11) type_name -> . VOID
    (12) type_name -> . STRING
    (13) type_name -> . CHAR
    (14) type_name -> . BOOLEAN
    (15) type_name -> . FLOAT
    (16) type_name -> . INTEGER
    ARRAY           shift and go to state 13
    VOID            shift and go to state 14
    STRING          shift and go to state 15
    CHAR            shift and go to state 16
    BOOLEAN         shift and go to state 17
    FLOAT           shift and go to state 18
    INTEGER         shift and go to state 19

    array_type                     shift and go to state 148
    type_name                      shift and go to state 149

state 135

    (17) array_type -> ARRAY [ expr ] type_name .
    ;               reduce using rule 17 (array_type -> ARRAY [ expr ] type_name .)
    =               reduce using rule 17 (array_type -> ARRAY [ expr ] type_name .)
    ,               reduce using rule 17 (array_type -> ARRAY [ expr ] type_name .)
    )               reduce using rule 17 (array_type -> ARRAY [ expr ] type_name .)


state 136

    (42) block_stmt -> { stmt_list } .
    FOR             reduce using rule 42 (block_stmt -> { stmt_list } .)
    IF              reduce using rule 42 (block_stmt -> { stmt_list } .)
    DO              reduce using rule 42 (block_stmt -> { stmt_list } .)
    WHILE           reduce using rule 42 (block_stmt -> { stmt_list } .)
    FALSE           reduce using rule 42 (block_stmt -> { stmt_list } .)
    TRUE            reduce using rule 42 (block_stmt -> { stmt_list } .)
    STRING_CONST    reduce using rule 42 (block_stmt -> { stmt_list } .)
    CHAR_CONST      reduce using rule 42 (block_stmt -> { stmt_list } .)
    FLOAT_CONST     reduce using rule 42 (block_stmt -> { stmt_list } .)
    INTEGER_CONST   reduce using rule 42 (block_stmt -> { stmt_list } .)
    ID              reduce using rule 42 (block_stmt -> { stmt_list } .)
    (               reduce using rule 42 (block_stmt -> { stmt_list } .)
    DEC             reduce using rule 42 (block_stmt -> { stmt_list } .)
    INC             reduce using rule 42 (block_stmt -> { stmt_list } .)
    NOT             reduce using rule 42 (block_stmt -> { stmt_list } .)
    -               reduce using rule 42 (block_stmt -> { stmt_list } .)
    {               reduce using rule 42 (block_stmt -> { stmt_list } .)
    RETURN          reduce using rule 42 (block_stmt -> { stmt_list } .)
    PRINT           reduce using rule 42 (block_stmt -> { stmt_list } .)
    }               reduce using rule 42 (block_stmt -> { stmt_list } .)
    ELSE            reduce using rule 42 (block_stmt -> { stmt_list } .)


state 137

    (35) stmt -> FOR ( opt_expr . ; opt_expr ; opt_expr ) stmt
    ;               shift and go to state 150


state 138

    (36) stmt -> IF ( expr . ) stmt ELSE stmt
    (37) stmt -> IF ( expr . ) stmt
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 151
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 139

    (38) stmt -> DO stmt WHILE . ( expr ) ;
    (               shift and go to state 152


state 140

    (39) stmt -> WHILE ( expr . ) stmt
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 153
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 141

    (41) return_stmt -> RETURN opt_expr ; .
    FOR             reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    IF              reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    DO              reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    WHILE           reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    FALSE           reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    TRUE            reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    STRING_CONST    reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    CHAR_CONST      reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    FLOAT_CONST     reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    INTEGER_CONST   reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    ID              reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    (               reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    DEC             reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    INC             reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    NOT             reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    -               reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    {               reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    RETURN          reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    PRINT           reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    }               reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)
    ELSE            reduce using rule 41 (return_stmt -> RETURN opt_expr ; .)


state 142

    (40) print_stmt -> PRINT opt_expr_list ; .
    FOR             reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    IF              reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    DO              reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    WHILE           reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    FALSE           reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    TRUE            reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    STRING_CONST    reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    CHAR_CONST      reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    FLOAT_CONST     reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    INTEGER_CONST   reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    ID              reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    (               reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    DEC             reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    INC             reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    NOT             reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    -               reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    {               reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    RETURN          reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    PRINT           reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    }               reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)
    ELSE            reduce using rule 40 (print_stmt -> PRINT opt_expr_list ; .)


state 143

    (10) decl_init -> ID : array_type = { opt_expr_list } ; .
    ID              reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    $end            reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    FOR             reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    IF              reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    DO              reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    WHILE           reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    FALSE           reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    TRUE            reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    STRING_CONST    reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    CHAR_CONST      reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    FLOAT_CONST     reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    INTEGER_CONST   reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    (               reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    DEC             reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    INC             reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    NOT             reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    -               reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    {               reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    RETURN          reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    PRINT           reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    }               reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)
    ELSE            reduce using rule 10 (decl_init -> ID : array_type = { opt_expr_list } ; .)


state 144

    (46) expr_list -> expr , expr_list .
    }               reduce using rule 46 (expr_list -> expr , expr_list .)
    ;               reduce using rule 46 (expr_list -> expr , expr_list .)
    )               reduce using rule 46 (expr_list -> expr , expr_list .)


state 145

    (56) expr -> ID [ expr ] .
    (80) lval -> ID [ expr ] .
    ;               reduce using rule 56 (expr -> ID [ expr ] .)
    ^               reduce using rule 56 (expr -> ID [ expr ] .)
    %               reduce using rule 56 (expr -> ID [ expr ] .)
    /               reduce using rule 56 (expr -> ID [ expr ] .)
    *               reduce using rule 56 (expr -> ID [ expr ] .)
    -               reduce using rule 56 (expr -> ID [ expr ] .)
    +               reduce using rule 56 (expr -> ID [ expr ] .)
    DEC             reduce using rule 56 (expr -> ID [ expr ] .)
    INC             reduce using rule 56 (expr -> ID [ expr ] .)
    MAYOR_IGUAL     reduce using rule 56 (expr -> ID [ expr ] .)
    MAYOR_QUE       reduce using rule 56 (expr -> ID [ expr ] .)
    MENOR_IGUAL     reduce using rule 56 (expr -> ID [ expr ] .)
    MENOR_QUE       reduce using rule 56 (expr -> ID [ expr ] .)
    NO_IGUAL        reduce using rule 56 (expr -> ID [ expr ] .)
    IGUAL           reduce using rule 56 (expr -> ID [ expr ] .)
    AND             reduce using rule 56 (expr -> ID [ expr ] .)
    OR              reduce using rule 56 (expr -> ID [ expr ] .)
    ]               reduce using rule 56 (expr -> ID [ expr ] .)
    ,               reduce using rule 56 (expr -> ID [ expr ] .)
    }               reduce using rule 56 (expr -> ID [ expr ] .)
    )               reduce using rule 56 (expr -> ID [ expr ] .)
    =               reduce using rule 80 (lval -> ID [ expr ] .)


state 146

    (57) expr -> ID ( opt_expr_list ) .
    ;               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    ^               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    %               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    /               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    *               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    -               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    +               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    DEC             reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    INC             reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    MAYOR_IGUAL     reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    MAYOR_QUE       reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    MENOR_IGUAL     reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    MENOR_QUE       reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    NO_IGUAL        reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    IGUAL           reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    AND             reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    OR              reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    ]               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    ,               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    }               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)
    )               reduce using rule 57 (expr -> ID ( opt_expr_list ) .)


state 147

    (23) param_list -> param_list , param .
    ,               reduce using rule 23 (param_list -> param_list , param .)
    )               reduce using rule 23 (param_list -> param_list , param .)


state 148

    (24) param -> ID : array_type .
    ,               reduce using rule 24 (param -> ID : array_type .)
    )               reduce using rule 24 (param -> ID : array_type .)


state 149

    (25) param -> ID : type_name .
    ,               reduce using rule 25 (param -> ID : type_name .)
    )               reduce using rule 25 (param -> ID : type_name .)


state 150

    (35) stmt -> FOR ( opt_expr ; . opt_expr ; opt_expr ) stmt
    (47) opt_expr -> . expr
    (48) opt_expr -> . empty
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (82) empty -> .
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    ;               reduce using rule 82 (empty -> .)

    opt_expr                       shift and go to state 154
    expr                           shift and go to state 109
    empty                          shift and go to state 110
    lval                           shift and go to state 43

state 151

    (36) stmt -> IF ( expr ) . stmt ELSE stmt
    (37) stmt -> IF ( expr ) . stmt
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    expr                           shift and go to state 53
    stmt                           shift and go to state 155
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 152

    (38) stmt -> DO stmt WHILE ( . expr ) ;
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42

    expr                           shift and go to state 156
    lval                           shift and go to state 43

state 153

    (39) stmt -> WHILE ( expr ) . stmt
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    expr                           shift and go to state 53
    stmt                           shift and go to state 157
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 154

    (35) stmt -> FOR ( opt_expr ; opt_expr . ; opt_expr ) stmt
    ;               shift and go to state 158


state 155

    (36) stmt -> IF ( expr ) stmt . ELSE stmt
    (37) stmt -> IF ( expr ) stmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 159
    FOR             reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    DO              reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    STRING_CONST    reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    CHAR_CONST      reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    FLOAT_CONST     reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    INTEGER_CONST   reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    ID              reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    (               reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    DEC             reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    INC             reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    NOT             reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    -               reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    {               reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    PRINT           reduce using rule 37 (stmt -> IF ( expr ) stmt .)
    }               reduce using rule 37 (stmt -> IF ( expr ) stmt .)


state 156

    (38) stmt -> DO stmt WHILE ( expr . ) ;
    (63) expr -> expr . ^ expr
    (64) expr -> expr . % expr
    (65) expr -> expr . / expr
    (66) expr -> expr . * expr
    (67) expr -> expr . - expr
    (68) expr -> expr . + expr
    (69) expr -> expr . DEC
    (70) expr -> expr . INC
    (71) expr -> expr . MAYOR_IGUAL expr
    (72) expr -> expr . MAYOR_QUE expr
    (73) expr -> expr . MENOR_IGUAL expr
    (74) expr -> expr . MENOR_QUE expr
    (75) expr -> expr . NO_IGUAL expr
    (76) expr -> expr . IGUAL expr
    (77) expr -> expr . AND expr
    (78) expr -> expr . OR expr
    )               shift and go to state 160
    ^               shift and go to state 71
    %               shift and go to state 72
    /               shift and go to state 73
    *               shift and go to state 74
    -               shift and go to state 75
    +               shift and go to state 76
    DEC             shift and go to state 77
    INC             shift and go to state 78
    MAYOR_IGUAL     shift and go to state 79
    MAYOR_QUE       shift and go to state 80
    MENOR_IGUAL     shift and go to state 81
    MENOR_QUE       shift and go to state 82
    NO_IGUAL        shift and go to state 83
    IGUAL           shift and go to state 84
    AND             shift and go to state 85
    OR              shift and go to state 86


state 157

    (39) stmt -> WHILE ( expr ) stmt .
    FOR             reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    DO              reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    STRING_CONST    reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    CHAR_CONST      reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    FLOAT_CONST     reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    INTEGER_CONST   reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    ID              reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    DEC             reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    INC             reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    NOT             reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    PRINT           reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 39 (stmt -> WHILE ( expr ) stmt .)


state 158

    (35) stmt -> FOR ( opt_expr ; opt_expr ; . opt_expr ) stmt
    (47) opt_expr -> . expr
    (48) opt_expr -> . empty
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (82) empty -> .
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 30
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    )               reduce using rule 82 (empty -> .)

    opt_expr                       shift and go to state 161
    expr                           shift and go to state 109
    empty                          shift and go to state 110
    lval                           shift and go to state 43

state 159

    (36) stmt -> IF ( expr ) stmt ELSE . stmt
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    expr                           shift and go to state 53
    stmt                           shift and go to state 162
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 160

    (38) stmt -> DO stmt WHILE ( expr ) . ;
    ;               shift and go to state 163


state 161

    (35) stmt -> FOR ( opt_expr ; opt_expr ; opt_expr . ) stmt
    )               shift and go to state 164


state 162

    (36) stmt -> IF ( expr ) stmt ELSE stmt .
    FOR             reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    DO              reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_CONST    reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    CHAR_CONST      reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INTEGER_CONST   reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ID              reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    DEC             reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INC             reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    NOT             reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINT           reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 36 (stmt -> IF ( expr ) stmt ELSE stmt .)


state 163

    (38) stmt -> DO stmt WHILE ( expr ) ; .
    FOR             reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    IF              reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    DO              reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    WHILE           reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    FALSE           reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    TRUE            reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    STRING_CONST    reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    CHAR_CONST      reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    FLOAT_CONST     reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    INTEGER_CONST   reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    ID              reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    (               reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    DEC             reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    INC             reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    NOT             reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    -               reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    {               reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    RETURN          reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    PRINT           reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    }               reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)
    ELSE            reduce using rule 38 (stmt -> DO stmt WHILE ( expr ) ; .)


state 164

    (35) stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) . stmt
    (30) stmt -> . expr ;
    (31) stmt -> . decl
    (32) stmt -> . block_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . print_stmt
    (35) stmt -> . FOR ( opt_expr ; opt_expr ; opt_expr ) stmt
    (36) stmt -> . IF ( expr ) stmt ELSE stmt
    (37) stmt -> . IF ( expr ) stmt
    (38) stmt -> . DO stmt WHILE ( expr ) ;
    (39) stmt -> . WHILE ( expr ) stmt
    (49) expr -> . FALSE
    (50) expr -> . TRUE
    (51) expr -> . STRING_CONST
    (52) expr -> . CHAR_CONST
    (53) expr -> . FLOAT_CONST
    (54) expr -> . INTEGER_CONST
    (55) expr -> . ID
    (56) expr -> . ID [ expr ]
    (57) expr -> . ID ( opt_expr_list )
    (58) expr -> . ( expr )
    (59) expr -> . DEC expr
    (60) expr -> . INC expr
    (61) expr -> . NOT expr
    (62) expr -> . - expr
    (63) expr -> . expr ^ expr
    (64) expr -> . expr % expr
    (65) expr -> . expr / expr
    (66) expr -> . expr * expr
    (67) expr -> . expr - expr
    (68) expr -> . expr + expr
    (69) expr -> . expr DEC
    (70) expr -> . expr INC
    (71) expr -> . expr MAYOR_IGUAL expr
    (72) expr -> . expr MAYOR_QUE expr
    (73) expr -> . expr MENOR_IGUAL expr
    (74) expr -> . expr MENOR_QUE expr
    (75) expr -> . expr NO_IGUAL expr
    (76) expr -> . expr IGUAL expr
    (77) expr -> . expr AND expr
    (78) expr -> . expr OR expr
    (79) expr -> . lval = expr
    (4) decl -> . decl_init
    (5) decl -> . ID : function_type ;
    (6) decl -> . ID : array_type ;
    (7) decl -> . ID : type_name = expr ;
    (8) decl -> . ID : type_name ;
    (42) block_stmt -> . { stmt_list }
    (41) return_stmt -> . RETURN opt_expr ;
    (40) print_stmt -> . PRINT opt_expr_list ;
    (80) lval -> . ID [ expr ]
    (81) lval -> . ID
    (9) decl_init -> . ID : function_type = { opt_stmt_list }
    (10) decl_init -> . ID : array_type = { opt_expr_list } ;
    FOR             shift and go to state 58
    IF              shift and go to state 59
    DO              shift and go to state 60
    WHILE           shift and go to state 61
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    STRING_CONST    shift and go to state 34
    CHAR_CONST      shift and go to state 35
    FLOAT_CONST     shift and go to state 36
    INTEGER_CONST   shift and go to state 37
    ID              shift and go to state 47
    (               shift and go to state 38
    DEC             shift and go to state 39
    INC             shift and go to state 40
    NOT             shift and go to state 41
    -               shift and go to state 42
    {               shift and go to state 48
    RETURN          shift and go to state 62
    PRINT           shift and go to state 63

    stmt                           shift and go to state 165
    expr                           shift and go to state 53
    decl                           shift and go to state 54
    block_stmt                     shift and go to state 55
    return_stmt                    shift and go to state 56
    print_stmt                     shift and go to state 57
    lval                           shift and go to state 43
    decl_init                      shift and go to state 5

state 165

    (35) stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .
    FOR             reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    IF              reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    DO              reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    WHILE           reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    FALSE           reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    TRUE            reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    STRING_CONST    reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    CHAR_CONST      reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    FLOAT_CONST     reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    INTEGER_CONST   reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    ID              reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    (               reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    DEC             reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    INC             reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    NOT             reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    -               reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    {               reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    RETURN          reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    PRINT           reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    }               reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)
    ELSE            reduce using rule 35 (stmt -> FOR ( opt_expr ; opt_expr ; opt_expr ) stmt .)


Conflicts:

shift/reduce conflict for ELSE in state 155 resolved as shift